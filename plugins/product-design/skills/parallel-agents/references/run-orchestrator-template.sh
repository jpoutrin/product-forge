#!/bin/bash
# =============================================================================
# Parallel Agent Orchestrator Template
# Generated by /parallel-run command
# =============================================================================
#
# Usage:
#   ./run-parallel.sh                    # Run all waves
#   ./run-parallel.sh --wave 1           # Run specific wave
#   MAX_CONCURRENT=5 ./run-parallel.sh   # Override concurrency
#
# Environment Variables:
#   MAX_CONCURRENT  - Max parallel agents (default: 3)
#   TIMEOUT_HOURS   - Timeout per task in hours (default: 2)
#
# =============================================================================

set -euo pipefail

# --- Configuration (replaced by /parallel-run) ---
PARALLEL_DIR="${PARALLEL_DIR:-parallel/TS-XXXX-slug}"
WORKSPACE_ROOT="${WORKSPACE_ROOT:-../workspaces}"
MAX_CONCURRENT="${MAX_CONCURRENT:-3}"
TIMEOUT_HOURS="${TIMEOUT_HOURS:-2}"
TIMEOUT_SECONDS=$((TIMEOUT_HOURS * 3600))

# --- Derived paths ---
TASKS_DIR="$PARALLEL_DIR/tasks"
PROMPTS_DIR="$PARALLEL_DIR/prompts"
LOG_DIR="$PARALLEL_DIR/logs"
SCRIPTS_DIR="$PARALLEL_DIR/scripts"

# --- Colors ---
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# --- Logging functions ---
log() { echo -e "${GREEN}[$(date +%H:%M:%S)]${NC} $1"; }
warn() { echo -e "${YELLOW}[$(date +%H:%M:%S)] WARNING:${NC} $1"; }
error() { echo -e "${RED}[$(date +%H:%M:%S)] ERROR:${NC} $1"; }
progress() { echo "[PROGRESS] $1"; }  # Machine-readable for Claude monitoring

# --- Task tracking ---
declare -A TASK_STATUS
declare -A TASK_PIDS
declare -A TASK_START_TIME

# =============================================================================
# WAVE DEFINITIONS (replaced by /parallel-run based on manifest.json)
# =============================================================================

# Example wave definitions - these are replaced by actual task data
# WAVE_1_TASKS=("task-001-users" "task-002-products" "task-003-shared")
# WAVE_2_TASKS=("task-004-orders" "task-005-api")

# --- Placeholder for wave definitions ---
# {{WAVE_DEFINITIONS}}

# =============================================================================
# FUNCTIONS
# =============================================================================

setup_directories() {
    log "Setting up directories..."
    mkdir -p "$WORKSPACE_ROOT" "$LOG_DIR"
}

create_worktree() {
    local task_name="$1"
    local branch_name="feature/$task_name"
    local worktree_path="$WORKSPACE_ROOT/$task_name"

    if [ -d "$worktree_path" ]; then
        warn "Worktree already exists: $worktree_path"
        return 0
    fi

    log "Creating worktree for $task_name..."
    if git worktree add "$worktree_path" -b "$branch_name" 2>/dev/null; then
        log "Created: $worktree_path (branch: $branch_name)"
    elif git worktree add "$worktree_path" "$branch_name" 2>/dev/null; then
        log "Using existing branch: $branch_name"
    else
        error "Failed to create worktree for $task_name"
        return 1
    fi
}

launch_agent() {
    local task_name="$1"
    local worktree_path="$WORKSPACE_ROOT/$task_name"
    local prompt_file="$PROMPTS_DIR/${task_name}.txt"
    local log_file="$LOG_DIR/${task_name}.log"

    if [ ! -f "$prompt_file" ]; then
        error "Prompt file not found: $prompt_file"
        return 1
    fi

    progress "wave=$CURRENT_WAVE task=$task_name status=started"
    TASK_STATUS[$task_name]="running"
    TASK_START_TIME[$task_name]=$(date +%s)

    (
        cd "$worktree_path"
        log "Launching agent for $task_name in $worktree_path..."

        # Run claude with timeout
        if timeout "${TIMEOUT_SECONDS}s" claude --dangerously-skip-permissions --print "$(cat "$prompt_file")" > "$log_file" 2>&1; then
            # Create completion marker
            touch .claude-task-complete

            # Count commits
            local commits=$(git log --oneline HEAD ^main 2>/dev/null | wc -l | tr -d ' ')
            progress "wave=$CURRENT_WAVE task=$task_name status=completed commits=$commits"
        else
            local exit_code=$?
            if [ $exit_code -eq 124 ]; then
                progress "wave=$CURRENT_WAVE task=$task_name status=failed error=timeout"
            else
                progress "wave=$CURRENT_WAVE task=$task_name status=failed error=exit_code_$exit_code"
            fi
        fi
    ) &

    TASK_PIDS[$task_name]=$!
}

wait_for_tasks() {
    local tasks=("$@")
    local running=0
    local completed=0
    local failed=0

    for task in "${tasks[@]}"; do
        if [ -n "${TASK_PIDS[$task]:-}" ]; then
            local pid="${TASK_PIDS[$task]}"
            if wait "$pid" 2>/dev/null; then
                ((completed++))
            else
                ((failed++))
            fi
        fi
    done

    log "Wave $CURRENT_WAVE complete: $completed completed, $failed failed"
    progress "wave=$CURRENT_WAVE status=completed tasks=$completed/$((completed+failed))"

    return $failed
}

run_wave() {
    local wave_num="$1"
    shift
    local tasks=("$@")

    CURRENT_WAVE=$wave_num
    log "=========================================="
    log "Starting Wave $wave_num (${#tasks[@]} tasks)"
    log "=========================================="
    progress "wave=$wave_num status=started"

    # Create worktrees for this wave
    for task in "${tasks[@]}"; do
        create_worktree "$task" || {
            error "Failed to create worktree for $task"
            return 1
        }
    done

    # Launch agents with concurrency limit
    local running_count=0
    local launched=()

    for task in "${tasks[@]}"; do
        # Wait if at max concurrency
        while [ $running_count -ge $MAX_CONCURRENT ]; do
            sleep 5
            running_count=0
            for t in "${launched[@]}"; do
                if [ -n "${TASK_PIDS[$t]:-}" ] && kill -0 "${TASK_PIDS[$t]}" 2>/dev/null; then
                    ((running_count++))
                fi
            done
        done

        launch_agent "$task"
        launched+=("$task")
        ((running_count++))

        # Small delay between launches to avoid race conditions
        sleep 2
    done

    # Wait for all tasks in this wave
    wait_for_tasks "${tasks[@]}"
    return $?
}

check_completion() {
    local task_name="$1"
    local worktree_path="$WORKSPACE_ROOT/$task_name"

    if [ -f "$worktree_path/.claude-task-complete" ]; then
        return 0
    fi
    return 1
}

cleanup_worktrees() {
    log "Cleaning up worktrees..."
    for worktree in "$WORKSPACE_ROOT"/task-*; do
        if [ -d "$worktree" ]; then
            local task_name=$(basename "$worktree")
            git worktree remove "$worktree" --force 2>/dev/null || true
            log "Removed worktree: $worktree"
        fi
    done
}

show_summary() {
    echo ""
    log "=========================================="
    log "Execution Summary"
    log "=========================================="
    echo ""

    echo "Branches created:"
    for task in "${!TASK_STATUS[@]}"; do
        local branch="feature/$task"
        if git rev-parse --verify "$branch" >/dev/null 2>&1; then
            local commits=$(git log --oneline "main..$branch" 2>/dev/null | wc -l | tr -d ' ')
            echo "  - $branch ($commits commits)"
        fi
    done

    echo ""
    echo "Logs available in: $LOG_DIR/"
    echo ""
    echo "Next step: /parallel-integrate --parallel-dir $PARALLEL_DIR"
}

# =============================================================================
# MAIN
# =============================================================================

main() {
    local specific_wave=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --wave)
                specific_wave="$2"
                shift 2
                ;;
            --help)
                echo "Usage: $0 [--wave N]"
                echo ""
                echo "Options:"
                echo "  --wave N    Run only wave N"
                echo ""
                echo "Environment:"
                echo "  MAX_CONCURRENT=$MAX_CONCURRENT"
                echo "  TIMEOUT_HOURS=$TIMEOUT_HOURS"
                exit 0
                ;;
            *)
                error "Unknown option: $1"
                exit 1
                ;;
        esac
    done

    log "Parallel Execution: $PARALLEL_DIR"
    log "Workspace: $WORKSPACE_ROOT"
    log "Max Concurrent: $MAX_CONCURRENT"
    log "Timeout: ${TIMEOUT_HOURS}h per task"
    echo ""

    setup_directories

    local total_failed=0

    # {{WAVE_EXECUTION}}
    # This section is replaced by /parallel-run with actual wave execution calls
    # Example:
    # run_wave 1 "${WAVE_1_TASKS[@]}" || ((total_failed++))
    # run_wave 2 "${WAVE_2_TASKS[@]}" || ((total_failed++))

    if [ $total_failed -gt 0 ]; then
        error "Execution completed with $total_failed failed wave(s)"
        progress "execution status=failed waves_failed=$total_failed"
        exit 1
    else
        log "All waves completed successfully!"
        progress "execution status=completed"
        show_summary
    fi
}

# Run main with all arguments
main "$@"
